/**
 * JavaScript Code Generator
 *
 * Compiles validated AST to JavaScript code.
 * Generates readable, formatted JavaScript that can be executed by Node.js or browsers.
 */

import {
    Program,
    Statement,
    Expression,
    VariableDeclaration,
    BlockStatement,
    IfStatement,
    WhileStatement,
    ForStatement,
    ReturnStatement,
    BreakStatement,
    ContinueStatement,
    ExpressionStatement,
    AssignmentExpression,
    BinaryExpression,
    UnaryExpression,
    LogicalExpression,
    Identifier,
    LiteralExpression,
    GroupingExpression,
    CallExpression
} from '../ast';

import { TokenType } from '../core';

export interface CodeGenOptions {
    indentSize?: number;      // Number of spaces per indent level
    semicolons?: boolean;     // Add semicolons
    comments?: boolean;       // Add generated code comments
}

export class JavaScriptGenerator {
    private code: string[] = [];
    private indentLevel: number = 0;
    private options: Required<CodeGenOptions>;

    constructor(options: CodeGenOptions = {}) {
        this.options = {
            indentSize: options.indentSize ?? 2,
            semicolons: options.semicolons ?? true,
            comments: options.comments ?? false
        };
    }

    /**
     * Generate JavaScript code from AST
     */
    generate(program: Program): string {
        this.code = [];
        this.indentLevel = 0;

        if (this.options.comments) {
            this.emit('// Generated by JS Mini Engine\n');
        }

        for (const statement of program.body) {
            this.generateStatement(statement);
        }

        return this.code.join('');
    }

    // ========================================================================
    // CODE EMISSION HELPERS
    // ========================================================================

    private emit(code: string): void {
        this.code.push(code);
    }

    private emitLine(code: string = ''): void {
        if (code) {
            this.emit(this.indent() + code + '\n');
        } else {
            this.emit('\n');
        }
    }

    private indent(): string {
        return ' '.repeat(this.indentLevel * this.options.indentSize);
    }

    private increaseIndent(): void {
        this.indentLevel++;
    }

    private decreaseIndent(): void {
        this.indentLevel--;
    }

    private semi(): string {
        return this.options.semicolons ? ';' : '';
    }

    // ========================================================================
    // STATEMENT GENERATION
    // ========================================================================

    private generateStatement(stmt: Statement): void {
        switch (stmt.type) {
            case 'VariableDeclaration':
                this.generateVariableDeclaration(stmt as VariableDeclaration);
                break;

            case 'ExpressionStatement':
                this.generateExpressionStatement(stmt as ExpressionStatement);
                break;

            case 'BlockStatement':
                this.generateBlockStatement(stmt as BlockStatement);
                break;

            case 'IfStatement':
                this.generateIfStatement(stmt as IfStatement);
                break;

            case 'WhileStatement':
                this.generateWhileStatement(stmt as WhileStatement);
                break;

            case 'ForStatement':
                this.generateForStatement(stmt as ForStatement);
                break;

            case 'ReturnStatement':
                this.generateReturnStatement(stmt as ReturnStatement);
                break;

            case 'BreakStatement':
                this.generateBreakStatement(stmt as BreakStatement);
                break;

            case 'ContinueStatement':
                this.generateContinueStatement(stmt as ContinueStatement);
                break;

            default:
                throw new Error(`Unknown statement type: ${(stmt as any).type}`);
        }
    }

    private generateVariableDeclaration(stmt: VariableDeclaration): void {
        const kind = stmt.kind;
        const name = stmt.identifier.name;

        this.emit(this.indent() + kind + ' ' + name);

        if (stmt.initializer) {
            this.emit(' = ');
            this.generateExpression(stmt.initializer);
        }

        this.emit(this.semi() + '\n');
    }

    private generateExpressionStatement(stmt: ExpressionStatement): void {
        this.emit(this.indent());
        this.generateExpression(stmt.expression);
        this.emit(this.semi() + '\n');
    }

    private generateBlockStatement(stmt: BlockStatement, inline: boolean = false): void {
        if (!inline) {
            this.emitLine('{');
        } else {
            this.emit('{\n');
        }

        this.increaseIndent();

        for (const statement of stmt.body) {
            this.generateStatement(statement);
        }

        this.decreaseIndent();

        if (!inline) {
            this.emitLine('}');
        } else {
            this.emit(this.indent() + '}');
        }
    }

    private generateIfStatement(stmt: IfStatement): void {
        this.emit(this.indent() + 'if (');
        this.generateExpression(stmt.condition);
        this.emit(') ');

        if (stmt.consequent.type === 'BlockStatement') {
            this.generateBlockStatement(stmt.consequent as BlockStatement, true);
        } else {
            this.emit('{\n');
            this.increaseIndent();
            this.generateStatement(stmt.consequent);
            this.decreaseIndent();
            this.emit(this.indent() + '}');
        }

        if (stmt.alternate) {
            this.emit(' else ');

            if (stmt.alternate.type === 'IfStatement') {
                const ifStmt = stmt.alternate as IfStatement;
                this.emit('if (');
                this.generateExpression(ifStmt.condition);
                this.emit(') ');

                if (ifStmt.consequent.type === 'BlockStatement') {
                    this.generateBlockStatement(ifStmt.consequent as BlockStatement, true);
                } else {
                    this.emit('{\n');
                    this.increaseIndent();
                    this.generateStatement(ifStmt.consequent);
                    this.decreaseIndent();
                    this.emit(this.indent() + '}');
                }

                if (ifStmt.alternate) {
                    this.emit(' else ');
                    if (ifStmt.alternate.type === 'BlockStatement') {
                        this.generateBlockStatement(ifStmt.alternate as BlockStatement, true);
                    } else {
                        this.emit('{\n');
                        this.increaseIndent();
                        this.generateStatement(ifStmt.alternate);
                        this.decreaseIndent();
                        this.emit(this.indent() + '}');
                    }
                }
            } else if (stmt.alternate.type === 'BlockStatement') {
                this.generateBlockStatement(stmt.alternate as BlockStatement, true);
            } else {
                this.emit('{\n');
                this.increaseIndent();
                this.generateStatement(stmt.alternate);
                this.decreaseIndent();
                this.emit(this.indent() + '}');
            }
        }

        this.emit('\n');
    }

    private generateWhileStatement(stmt: WhileStatement): void {
        this.emit(this.indent() + 'while (');
        this.generateExpression(stmt.condition);
        this.emit(') ');

        if (stmt.body.type === 'BlockStatement') {
            this.generateBlockStatement(stmt.body as BlockStatement, true);
        } else {
            this.emit('{\n');
            this.increaseIndent();
            this.generateStatement(stmt.body);
            this.decreaseIndent();
            this.emit(this.indent() + '}');
        }

        this.emit('\n');
    }

    private generateForStatement(stmt: ForStatement): void {
        this.emit(this.indent() + 'for (');

        if (stmt.init) {
            if (stmt.init.type === 'VariableDeclaration') {
                const varDecl = stmt.init as VariableDeclaration;
                this.emit(varDecl.kind + ' ' + varDecl.identifier.name);
                if (varDecl.initializer) {
                    this.emit(' = ');
                    this.generateExpression(varDecl.initializer);
                }
            } else {
                this.generateExpression((stmt.init as ExpressionStatement).expression);
            }
        }

        this.emit('; ');

        if (stmt.condition) {
            this.generateExpression(stmt.condition);
        }

        this.emit('; ');

        if (stmt.update) {
            this.generateExpression(stmt.update);
        }

        this.emit(') ');

        if (stmt.body.type === 'BlockStatement') {
            this.generateBlockStatement(stmt.body as BlockStatement, true);
        } else {
            this.emit('{\n');
            this.increaseIndent();
            this.generateStatement(stmt.body);
            this.decreaseIndent();
            this.emit(this.indent() + '}');
        }

        this.emit('\n');
    }

    private generateReturnStatement(stmt: ReturnStatement): void {
        this.emit(this.indent() + 'return');

        if (stmt.argument) {
            this.emit(' ');
            this.generateExpression(stmt.argument);
        }

        this.emit(this.semi() + '\n');
    }

    private generateBreakStatement(_stmt: BreakStatement): void {
        this.emitLine('break' + this.semi());
    }

    private generateContinueStatement(_stmt: ContinueStatement): void {
        this.emitLine('continue' + this.semi());
    }

    // ========================================================================
    // EXPRESSION GENERATION
    // ========================================================================

    private generateExpression(expr: Expression): void {
        switch (expr.type) {
            case 'LiteralExpression':
                this.generateLiteral(expr as LiteralExpression);
                break;

            case 'Identifier':
                this.generateIdentifier(expr as Identifier);
                break;

            case 'BinaryExpression':
                this.generateBinaryExpression(expr as BinaryExpression);
                break;

            case 'UnaryExpression':
                this.generateUnaryExpression(expr as UnaryExpression);
                break;

            case 'LogicalExpression':
                this.generateLogicalExpression(expr as LogicalExpression);
                break;

            case 'AssignmentExpression':
                this.generateAssignmentExpression(expr as AssignmentExpression);
                break;

            case 'GroupingExpression':
                this.generateGroupingExpression(expr as GroupingExpression);
                break;

            case 'CallExpression':
                this.generateCallExpression(expr as CallExpression);
                break;

            default:
                throw new Error(`Unknown expression type: ${(expr as any).type}`);
        }
    }

    private generateLiteral(expr: LiteralExpression): void {
        const value = expr.value;

        if (typeof value === 'string') {
            const escaped = value.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
            this.emit('"' + escaped + '"');
        } else if (value === null) {
            this.emit('null');
        } else {
            this.emit(String(value));
        }
    }

    private generateIdentifier(expr: Identifier): void {
        this.emit(expr.name);
    }

    private generateBinaryExpression(expr: BinaryExpression): void {
        this.generateExpression(expr.left);
        this.emit(' ' + this.operatorToString(expr.operator) + ' ');
        this.generateExpression(expr.right);
    }

    private generateUnaryExpression(expr: UnaryExpression): void {
        this.emit(this.operatorToString(expr.operator));
        this.generateExpression(expr.argument);
    }

    private generateLogicalExpression(expr: LogicalExpression): void {
        this.generateExpression(expr.left);
        this.emit(' ' + this.operatorToString(expr.operator) + ' ');
        this.generateExpression(expr.right);
    }

    private generateAssignmentExpression(expr: AssignmentExpression): void {
        this.emit(expr.left.name);
        this.emit(' = ');
        this.generateExpression(expr.right);
    }

    private generateGroupingExpression(expr: GroupingExpression): void {
        this.emit('(');
        this.generateExpression(expr.expression);
        this.emit(')');
    }

    private generateCallExpression(expr: CallExpression): void {
        this.generateExpression(expr.callee);
        this.emit('(');

        for (let i = 0; i < expr.arguments.length; i++) {
            this.generateExpression(expr.arguments[i]);
            if (i < expr.arguments.length - 1) {
                this.emit(', ');
            }
        }

        this.emit(')');
    }

    // ========================================================================
    // UTILITIES
    // ========================================================================

    private operatorToString(operator: TokenType): string {
        switch (operator) {
            case TokenType.PLUS: return '+';
            case TokenType.MINUS: return '-';
            case TokenType.STAR: return '*';
            case TokenType.SLASH: return '/';
            case TokenType.PERCENT: return '%';
            case TokenType.LESS: return '<';
            case TokenType.LESS_EQUAL: return '<=';
            case TokenType.GREATER: return '>';
            case TokenType.GREATER_EQUAL: return '>=';
            case TokenType.EQUAL_EQUAL: return '==';
            case TokenType.BANG_EQUAL: return '!=';
            case TokenType.BANG: return '!';
            case TokenType.AND: return '&&';
            case TokenType.OR: return '||';
            case TokenType.EQUAL: return '=';
            default:
                throw new Error(`Unknown operator: ${operator}`);
        }
    }

    /**
     * Reset generator state
     */
    reset(): void {
        this.code = [];
        this.indentLevel = 0;
    }
}
